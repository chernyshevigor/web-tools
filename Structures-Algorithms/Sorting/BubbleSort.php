<?php

$x = [1, 34, 5, 8, 17, 11, 7];
BubbleSort::get($x);
print_r($x);
exit;

/*
 * Worst O(n^2)
 * Average O(n^2)
 * Best O(n)
 */
class BubbleSort
{
    /**
     * @param int[] $in
     * @return void
     */
    public static function get(array &$in): void
    {
        $size = count($in) - 1;
        for ($i = 0; $i < $size; $i++) {
            for ($j = 0; $j < $size - $i; $j++) {
                $k = $j + 1;
                if ($in[$k] < $in[$j]) {
                    [$in[$j], $in[$k]] = [$in[$k], $in[$j]];
                }
            }
        }
    }

    /**
     * @param int[] $in
     * @return int[]
     */
    public static function get2(array $in): array
    {
        do {
            $swapped = false;
            for ($i = 0, $c = count($in) - 1; $i < $c; $i++) {
                if ($in[$i] > $in[$i + 1]) {
                    // list($in[$i + 1], $in[$i]) = [$in[$i], $in[$i + 1]];
                    [$in[$i + 1], $in[$i]] = [$in[$i], $in[$i + 1]];
                    $swapped = true;
                }
            }
        } while ($swapped);
        return $in;
    }
}

/*
Сортировка простыми обменами. Обходим массив от начала до конца, попутно меняя местами неотсортированные соседние элементы.
В результате первого прохода на последнее место «всплывёт» максимальный элемент.
Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего)
и меняем по пути неотсортированных соседей. Второй по величине элемент окажется на предпоследнем месте.
Если за проход не произошло ни одного обмена, то массив отсортирован.
Продолжая в том же духе, будем обходить всё уменьшающуюся неотсортированную часть массива,
запихивая найденные максимумы в конец. Очевидно, не более чем после n итераций массив будет отсортирован.
*/
